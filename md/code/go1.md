# Go go go!

兼具Python等动态语言的开发速度和C/C++等编译型语言的性能与安全性

- 能访问底层操作系统
- 强大的网络编程和并发编程支持
- 系统编程、分布式编程
- 部署简单、并发性好、语言设计良好、执行性能好

独具个性

- 没有类和继承的概念
- 通过接口interface的概念来实现多态性
- 有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说——混合型

成果

Docker、Go-Ethereum、Thrraform和Kubernetes

## 编译型语言

- 编译器将源代码编译成二进制（或字节码）格式
- 在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件
- 步骤：编辑－保存－编译－运行，不同于Python、Ruby和JavaScript

## 为什么要学习Go！

- 应对创建大型并发网络程序面临的挑战
- 快速编译，高效执行，易于开发
- 交叉编译；第一门完全支持UTF-8的编程语言——真正的国际化
- 可以处理使用UTF-8编码的字符串，源码文件格式都是使用UTF-8编码

接下来从几个方面来具体介绍一下Go语言的特性。
抛开语法样式不谈，单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是Go语言被冠以“NextC”名号的重要原因。
[C语言](http://c.biancheng.net/c/)
Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。任何人写出的代码都基本一致，这使得Go语言简单易学。放弃部分“灵活”和“自由”，换来更好的维护性，我觉得是值得的。

时至今日，并发编程已成为程序员的基本技能，在各个技术社区都能看到诸多与之相关的讨论主题。在这种情况下Go语言却一反常态做了件极大胆的事，从根本上将一切都并发化，运行时用 Goroutine 运行所有的一切，包括 main.main 入口函数。

搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。

## 内存分配

将一切并发化固然是好，但带来的问题同样很多。如何实现高并发下的内存分配和管理就是个难题。好在 Go 选择了 tcmalloc，它本就是为并发而设计的高性能内存分配组件。
可以说，内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。

垃圾回收一直是个难题。早年间， 就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰。

每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 STW 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。尽管有了努力，当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。

## 静态链接

Go 刚发布时，静态链接被当作优点宣传。只须编译后的一个可执行文件，无须附加任何东西就能部署。这似乎很不错，只是后来风气变了。连着几个版本，编译器都在完善动态库 buildmode 功能，场面一时变得有些尴尬。
暂不说未完工的 buildmode 模式，静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。这种简单方式对于编写系统软件有着极大好处，因为库依赖一直都是个麻烦。

## 标准库

功能完善、质量可靠的标准库为编程语言提供了充足动力。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。最关键的是，标准库有升级和修复保障，还能从运行时获得深层次优化的便利，这是第三方库所不具备的。
Go 标准库虽称不得完全覆盖，但也算极为丰富。其中值得称道的是 net/http，仅须简单几条语句就能实现一个高性能 Web Server，这从来都是宣传的亮点。更何况大批基于此的优秀第三方 Framework 更是将 Go 推到 Web/Microservice 开发标准之一的位置。

完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。

除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。

在早期 CPU 都是以单核的形式顺序执行机器指令。[Go语言](http://c.biancheng.net/golang/)[C语言](http://c.biancheng.net/c/)
随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇。相应地，编程语言也开始逐步向并行化的方向发展。

作为程序员，要开发出能充分利用硬件资源的应用程序是一件很难的事情。现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。编程时需要写大量的线程同步代码来利用多个核，很容易导致错误。

Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。
[数据结构](http://c.biancheng.net/data_structure/)
程序可以将需要并发的环节设计为生产者模式和消费者的模式，将数据放入通道。通道另外一端的代码将这些数据进行并发计算并返回结果，如下图所示。

> 提示：Go语言通过通道可以实现多个 goroutine 之间内存共享。

【实例】生产者每秒生成一个字符串，并通过通道传给消费者，生产者使用两个 goroutine 并发运行，消费者在 main() 函数的 goroutine 中进行处理。

```
package mainimport (        "fmt"        "math/rand"        "time")// 数据生产者func producer(header string, channel chan<- string) {     // 无限循环, 不停地生产数据     for {            // 将随机数和字符串格式化为字符串发送给通道            channel <- fmt.Sprintf("%s: %v", header, rand.Int31())            // 等待1秒            time.Sleep(time.Second)        }}// 数据消费者func customer(channel <-chan string) {     // 不停地获取数据     for {            // 从通道中取出数据, 此处会阻塞直到信道中返回数据            message := <-channel            // 打印数据            fmt.Println(message)        }}func main() {    // 创建一个字符串类型的通道    channel := make(chan string)    // 创建producer()函数的并发goroutine    go producer("cat", channel)    go producer("dog", channel)    // 数据消费函数    customer(channel)}
```

运行结果：

dog: 2019727887
cat: 1298498081
dog: 939984059
cat: 1427131847
cat: 911902081
dog: 1474941318
dog: 140954425
cat: 336122540
cat: 208240456
dog: 646203300

对代码的分析：

- 第 03 行，导入格式化（fmt）、随机数（math/rand）、时间（time）包参与编译。
- 第 10 行，生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道。
- 第 13 行，for{} 构成一个无限循环。
- 第 15 行，使用 rand.Int31() 生成一个随机数，使用 fmt.Sprintf() 函数将 header 和随机数格式化为字符串。
- 第 18 行，使用 time.Sleep() 函数暂停 1 秒再执行这个函数。如果在 goroutine 中执行时，暂停不会影响其他 goroutine 的执行。
- 第 23 行，消费数据的函数，传入一个只能写入的通道。
- 第 26 行，构造一个不断消费消息的循环。
- 第 28 行，从通道中取出数据。
- 第 31 行，将取出的数据进行打印。
- 第 35 行，程序的入口函数，总是在程序开始时执行。
- 第 37 行，实例化一个字符串类型的通道。
- 第 39 行和第 40 行，并发执行一个生产者函数，两行分别创建了这个函数搭配不同参数的两个 goroutine。
- 第 42 行，执行消费者函数通过通道进行数据消费。


整段代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字 go 实现 goroutine，和通道实现数据交换。

所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。[Go语言](http://c.biancheng.net/golang/)
使用Go语言开发的开源项目非常多。早期的Go语言开源项目只是通过Go语言与传统项目进行库绑定实现，例如 、Sqlite 等；后期的很多项目都使用Go语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用Go语言原生开发项目的出现。

## 1) [Docker](http://c.biancheng.net/docker/)

Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。
项目链接：Go语言自己的早期源码使用C语言和写成。从 Go 1.5 版本后，完全使用Go语言自身进行编写。Go语言的源码对了解Go语言的底层调度有极大的参考意义，建议希望对Go语言有深入了解的读者读一读。
https://github.com/golang/go

## 3) Kubernetes

Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 Container Pod（容器仓）。
项目链接：一款分布式、可靠的 KV 存储系统，可以快速进行云配置。由 CoreOS 开发并维护键值存储系统，它使用Go语言编写，并通过 Raft 一致性算法处理日志复制以保证强一致性。
https://github.com/coreos/etcd

## 5) beego

beego 是一个类似 [Python](http://c.biancheng.net/python/)
项目链接：一款快速构建模块化的 Web 应用的Go语言框架。
https://github.com/go-martini/martini

## 7) codis

国产的优秀分布式 [Redis](http://c.biancheng.net/redis/)
项目链接：Go语言强大的调试器，被很多集成环境和编辑器整合。
https://github.com/derekparker/delve

[Go语言](http://c.biancheng.net/golang/)是谷歌在 2009 年发布的一款编程语言，自面世以来它以高效的开发效率和完美的运行速度迅速风靡全球，被誉为“21 世纪的”。
[Docker](http://c.biancheng.net/docker/)
作为创造了Go语言的 google 公司，当然会力挺Go语言了。Google 有很多基于 Go 开发的开源项目，比如 kubernets，docker，大家可以参考《》一节了解更多的Go语言开源项目。

#### 2) Facebook

Facebook 也在使用Go语言，为此他们还专门在 Github 上建立了一个开源组织 facebookgo。大家可以通过 https://github.com/facebookgo
腾讯在 15 年就已经做了 Docker 万台规模的实践。因为腾讯主要的开发语言是 C/ ，所以在使用Go语言方面会方便很多，也有很多优势，不过日积月累的 C/C++ 代码很难改造，也不敢动，所以主要在新业务上尝试使用 Go。

#### 4) 百度

百度主要在运维方面使用到了Go语言，比如百度运维的一个 BFE 项目，主要负责前端流量的接入，其次就是百度消息通讯系统的服务器端也使用到了Go语言。
七牛云算是国内第一家选Go语言做服务端的公司。早在 2011 年，当Go语言的语法还没完全稳定下来的情况下，七牛云就已经选择将 Go 作为存储服务端的主体语言。

#### 6) 京东

京东云消息推送系统、云存储，以及京东商城的列表页等都是使用Go语言开发的。
小米对Go语言的支持，在于运维监控系统的开源，它的官方网址是 。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Go语言。

#### 8) 360

360 对Go语言的使用也不少，比如开源的日志搜索系统 Poseidon，大家可以通过 https://github.com/Qihoo360/poseidon
除了上面提到的，还有很多公司开始尝试使用Go语言，比如美团、滴滴、新浪等。
[Golang](http://c.biancheng.net/golang/)

前面我们已经介绍过了[Go语言](http://c.biancheng.net/golang/)
其实Go语言主要用作服务器端开发，其定位是用来开发“大型软件”的，适合于需要很多程序员一起开发，并且开发周期较长的大型软件和支持的网络服务。

鉴于Go语言的特点和设计的初衷，从以下几个方面来分析Go语言擅长的领域：

而且对于现在比较流行的技术方面，Go语言也是非常受欢迎的，很多基于区块链的 DApps（去中心化应用）和工具都是用的Go语言来实现的。

在软件行业做过一段时间的人都知道，没有万能的编程语言，也没有万能开发框架，更没有万能的解决方案。任何新技术的产生都应该归功于一部分人对老旧技术的强烈不满。[Go语言](http://c.biancheng.net/golang/)[C语言](http://c.biancheng.net/c/)[C++](http://c.biancheng.net/cplus/)[Java](http://c.biancheng.net/java/)[PHP](http://c.biancheng.net/php/)[Python](http://c.biancheng.net/python/)
Go语言是集多编程范式之大成者，体现了优秀的软件工程思想和原则，其特性可以使开发者快速地开发、测试和部署程序，大大提高了生产效率。下面我们来看看与其他主流语言相比，Go语言具有的优势。

2) 相对于 Java 来讲，Go语言拥有简明的类型系统、函数式编程范式和先进的并发编程模型。因此其代码块更小更简洁、可重用性更高，并可在多核计算环境下更快地运行。

4) 对于 Python/Ruby 来讲，Go 的优势在于其简洁的语法、非侵入式和扁平化的类型系统和浑然天成的多范式编程模型。与 PHP 一样，Python 和 Ruby 也是动态类型的解释型语言，这就意味着它们的运行速度会比静态类型的编译型语言慢很多。

下面，我们来客观地看一下目前Go语言需要加强或改进的地方（虽然有些 Gopher 并不这么认为）。

2) 从程序运行速度的角度来看，Go语言虽然已与 Java 不相上下，但还不及 C（差距正在不断地缩小）。

另外，在更深的层面，Go语言标准库中也有些不尽如人意的的地方。具体如下。

2) 从并发编程角度来看，Go语言提供的并发模型很强大，但也有一些编写规则需要了解。否则，很容易踩进“坑”里。其实不提倡把这叫作“坑”。因为这些所谓的“坑”，大都是我们由于对原理不熟悉而自己挖出来的。

虽然Go语言还有一些瑕疵，但从整体来看，它已经是一门非常优秀的通用编程语言了。并且，Go语言在今后的发展上会关注性能、可靠性、可移植性和一些功能增强，所以上述缺憾会随着版本的推进而逐渐减弱和消失。

根据 Go 开发团队和基本的算法测试，[Go语言](http://c.biancheng.net/golang/)[C语言](http://c.biancheng.net/c/)
时下流行的语言大都是运行在虚拟机上，如： 和 Scala 使用的 JVM， 和 VB.NET 使用的 .NET CLR。尽管虚拟机的性能已经有了很大的提升，但任何使用 JIT 编译器和脚本语言解释器的编程语言（Ruby、、Perl 和 ）在 C 和 的绝对优势下甚至都无法在性能上望其项背。

通过对 C(gcc)、C++、Java、JavaScript 和Go语言的测试。性能比较如下表所示，表中数据的单位为秒，数值越小表明运行性能越好。

学习编程语言，早已不是学一点语法规则那么简单。现在更习惯称作选择 Ecosystem（生态圈），而这其中标准库的作用和分量尤为明显。
在的安装文件里包含了一些可以直接使用的包，即标准库。Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含 I/O 操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。
[Linux](http://c.biancheng.net/linux_tutorial/)
Go语言的编译器也是标准库的一部分，通过词法器扫描源码，使用语法树获得源码逻辑分支等。Go语言的周边工具也是建立在这些标准库上。在标准库上可以完成几乎大部分的需求。



| Go语言标准库包名 | 功  能                                                       |
| ---------------- | ------------------------------------------------------------ |
| bufio            | 带缓冲的 I/O 操作                                            |
| bytes            | 实现字节操作                                                 |
| container        | 封装堆、列表和环形列表等容器                                 |
| crypto           | 加密算法                                                     |
| database         | 数据库驱动和接口                                             |
| debug            | 各种调试文件格式访问及调试功能                               |
| encoding         | 常见算法如 JSON、XML、Base64 等                              |
| flag             | 命令行解析                                                   |
| fmt              | 格式化操作                                                   |
| go               | Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改 |
| html             | HTML 转义及模板系统                                          |
| image            | 常见图形格式的访问及生成                                     |
| io               | 实现 I/O 原始访问接口及访问封装                              |
| math             | 数学库                                                       |
| net              | 网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等                |
| os               | 操作系统平台不依赖平台操作封装                               |
| path             | 兼容各操作系统的路径操作实用函数                             |
| plugin           | Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载        |
| reflect          | 语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值 |
| regexp           | 正则表达式封装                                               |
| runtime          | 运行时接口                                                   |
| sort             | 排序接口                                                     |
| strings          | 字符串转换、解析及实用函数                                   |
| time             | 时间接口                                                     |
| text             | 文本模板及 Token 词法器                                      |


当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。

[Go语言](http://c.biancheng.net/golang/)语法简单易懂，学习曲线平缓，不需要像 C/ [C语言](http://c.biancheng.net/c/)
Go语言是 Google 公司开发的一种静态型、编译型并自带垃圾回收和并发的编程语言。所以它是一门类型安全的语言，加上通过构建到本地代码，程序的执行速度也非常快。

Go语言在拥有一些动态语言的特性的同时，其语法风格类似于C语言。在C语言的基础上进行了大幅的简化，去掉了不需要的表达式括号，循环也只有 for 一种表示方法，就可以实现数值、键值等各种遍历。因此，Go语言上手非常容易。

Go语言这种从零开始使用到解决问题的速度，在其他语言中是完全不可想象的。学过 C++ 的朋友都知道，一到两年大强度的理论学习和实战操练也只能学到这门语言的皮毛，以及知道一些基本的避免错误的方法。

【实例】HTTP 文件服务器是常见的 Web 服务之一。开发阶段为了测试，需要自行安装 Apache 或 Nginx 服务器，下载安装配置需要大量的时间。使用Go语言实现一个简单的 HTTP 服务器只需要几行代码，如下所示。

[Go语言](http://c.biancheng.net/golang/)语法类似于，因此熟悉C语言及其派生语言（、、Objective-C 等）的人都会迅速熟悉这门语言。

## 1) 去掉循环冗余括号

Go语言在众多大师的丰富实战经验的基础上诞生，去除了C语言语法中一些冗余、烦琐的部分。下面的代码是C语言的数值循环：

```
// C语言的for数值循环for(int a = 0;a<10;a++){    // 循环代码}
```

在Go语言中，这样的循环变为：

```
for a := 0;a<10;a++{    // 循环代码}
```

for 两边的括号被去掉，int 声明被简化为`:=`

## 2) 去掉表达式冗余括号

同样的简化也可以在判断语句中体现出来，以下是C语言的判断语句：

```
if (表达式){    // 表达式成立}
```

在Go语言中，无须添加表达式括号，代码如下：

```
if 表达式{    // 表达式成立}
```

## 3) 强制的代码风格

Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。这个特性刚开始会使开发者有一些不习惯，但随着对Go语言的不断熟悉，开发者就会发现风格统一让大家在阅读代码时把注意力集中到了解决问题上，而不是代码风格上。
同时Go语言也提供了一套格式化工具。一些Go语言的开发环境或者编辑器在保存时，都会使用格式化工具对代码进行格式化，让代码提交时已经是统一格式的代码。

## 4) 不再纠结于 i++ 和 ++i

C语言非常经典的考试题为：

```
int a, b;a = i++;b = ++i;
```

这种题目对于初学者简直摸不着头脑。为什么一个简单的自增表达式需要有两种写法？
在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：如果写成前置自增，或者赋值后自增都将导致编译错误。

[Go语言](http://c.biancheng.net/golang/)是一门需要编译才能运行的编程语言，也就说代码在运行之前需要通过编译器生成二进制机器码，随后二进制文件才能在目标机器上运行，如果我们想要了解Go语言的实现原理，理解它的编译过程就是一个没有办法绕过的事情。

## 预备知识

想要深入了解Go语言的编译过程，需要提前了解一下编译过程中涉及的一些术语和专业知识。这些知识其实在我们的日常工作和学习中比较难用到，但是对于理解编译的过程和原理还是非常重要的。
在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。

以算术表达式 1+3*(4-1)+2 为例，可以解析出的抽象语法树如下图所示：


在编译器设计中，静态单赋值形式（static single assignment form，通常简写为 SSA form 或是 SSA）是中介码（IR，intermediate representation）的属性，它要求每个变量只分配一次，并且变量需要在使用之前定义。在实践中我们通常会用添加下标的方式实现每个变量只能被赋值一次的特性，这里以下面的代码举一个简单的例子：

x := 1
x := 2
y := x

从上面的描述所知，第一行赋值行为是不需要的，因为 x 在第二行被二度赋值并在第三行被使用，在 SSA 下，将会变成下列的形式：
从使用 SSA 的中间代码我们就可以非常清晰地看出变量 y1 的值和 x1 是完全没有任何关系的，所以在机器码生成时其实就可以省略第一步，这样就能减少需要执行的指令来优化这一段代码。



最后要介绍的一个预备知识就是指令集架构了，指令集架构（Instruction Set Architecture，简称 ISA），又称指令集或指令集体系，是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部 I/O。指令集架构包含一系列的 opcode 即操作码（机器语言），以及由特定处理器执行的基本命令。

- 复杂指令集运算（Complex Instruction Set Computing，简称 CISC）；
- 精简指令集运算（Reduced Instruction Set Computing，简称 RISC）；
- 显式并行指令集运算（Explicitly Parallel Instruction Computing，简称 EPIC）；
- 超长指令字指令集运算（VLIW）。


不同的处理器（CPU）使用了大不相同的机器语言，所以我们的程序想要在不同的机器上运行，就需要将源代码根据架构编译成不同的机器语言。

## 编译原理

Go语言编译器的源代码在 cmd/compile 目录中，目录下的文件共同构成了Go语言的编译器，学过编译原理的人可能听说过编译器的前端和后端，编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的机器码。![img](http://c.biancheng.net/uploads/allimg/191115/4-19111511533W48.gif)


Go的编译器在逻辑上可以被分成四个阶段：词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成，下面我们来分别介绍一下这四个阶段做的工作。

#### 1) 词法与语法分析

所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）。
而语法分析的输入就是词法分析器输出的 Token 序列，这些序列会按照顺序被语法分析器进行解析，语法的解析过程就是将词法分析生成的 Token 按照语言定义好的文法（Grammar）自下而上或者自上而下的进行规约，每一个 Go 的源代码文件最终会被归纳成一个 SourceFile 结构：

SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" }

标准的 
如果在语法解析的过程中发生了任何语法错误，都会被语法解析器发现并将消息打印到标准输出上，整个编译过程也会随着错误的出现而被中止。

#### 2) 类型检查

当拿到一组文件的抽象语法树 AST 之后，Go语言的编译器会对语法树中定义和使用的类型进行检查，类型检查分别会按照顺序对不同类型的节点进行验证，按照以下的顺序进行处理：


类型检查的阶段不止会对树状结构的节点进行验证，同时也会对一些内建的函数进行展开和改写，例如 make 关键字在这个阶段会根据子树的结构被替换成 makeslice 或者 makechan 等函数。

当我们将源文件转换成了抽象语法树，对整个语法树的语法进行解析并进行类型检查之后，就可以认为当前文件中的代码基本上不存在无法编译或者语法错误的问题了，Go语言的编译器就会将输入的 AST 转换成中间代码。

在类型检查之后，就会通过一个名为 compileFunctions 的函数开始对整个Go语言项目中的全部函数进行编译，这些函数会在一个编译队列中等待几个后端工作协程的消费，这些 Goroutine 会将所有函数对应的 AST 转换成使用 SSA 特性的中间代码。

#### 4) 机器码生成

Go语言源代码的 cmd/compile/internal 目录中包含了非常多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包进行生成 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm，也就是说Go语言能够在几乎全部常见的 CPU 指令集类型上运行。
Go语言的编译器入口是 src/cmd/compile/internal/gc 包中的 main.go 文件，这个 600 多行的 Main 函数就是Go语言编译器的主程序，这个函数会先获取命令行传入的参数并更新编译的选项和配置，随后就会开始运行 parseFiles 函数对输入的所有文件进行词法与语法分析得到文件对应的抽象语法树：

func Main(archInit func(*Arch)) {
  // ...

  lines := parseFiles(flag.Args())

接下来就会分九个阶段对抽象语法树进行更新和编译，就像我们在上面介绍的，整个过程会经历类型检查、SSA 中间代码生成以及机器码生成三个部分：

- 检查常量、类型和函数的类型；
- 处理变量的赋值；
- 对函数的主体进行类型检查；
- 决定如何捕获变量；
- 检查内联函数的类型；
- 进行逃逸分析；
- 将闭包的主体转换成引用的捕获变量；
- 编译顶层函数；
- 检查外部依赖的声明；

了解了剩下的编译过程之后，我们重新回到词法和语法分析后的具体流程，在这里编译器会对生成语法树中的节点执行类型检查，除了常量、类型和函数这些顶层声明之外，它还会对变量的赋值语句、函数主体等结构进行检查：

```go
for i := 0; i < len(xtop); i++ {
    n := xtop[i]
    if op := n.Op; op != ODCL && op != OAS && op != OAS2 && (op != ODCLTYPE || !n.Left.Name.Param.Alias) {
        xtop[i] = typecheck(n, ctxStmt)
    }
}

for i := 0; i < len(xtop); i++ {
    n := xtop[i]
    if op := n.Op; op == ODCL || op == OAS || op == OAS2 || op == ODCLTYPE && n.Left.Name.Param.Alias {
        xtop[i] = typecheck(n, ctxStmt)
    }
}

for i := 0; i < len(xtop); i++ {
    n := xtop[i]
    if op := n.Op; op == ODCLFUNC || op == OCLOSURE {
        typecheckslice(Curfn.Nbody.Slice(), ctxStmt)
    }
}

checkMapKeys()

for _, n := range xtop {
    if n.Op == ODCLFUNC && n.Func.Closure != nil {
        capturevars(n)
    }
}

escapes(xtop)

for _, n := range xtop {
    if n.Op == ODCLFUNC && n.Func.Closure != nil {
        transformclosure(n)
    }
}
```

类型检查会对传入节点的子节点进行遍历，这个过程会对 make 等关键字进行展开和重写，类型检查结束之后并没有输出新的[数据结构](http://c.biancheng.net/data_structure/)，只是改变了语法树中的一些节点，同时这个过程的结束也意味着源代码中已经不存在语法错误和类型错误，中间代码和机器码也都可以正常的生成了。

```go
    initssaconfig()

    peekitabs()

    for i := 0; i < len(xtop); i++ {
        n := xtop[i]
        if n.Op == ODCLFUNC {
            funccompile(n)
        }
    }

    compileFunctions()

    for i, n := range externdcl {
        if n.Op == ONAME {
            externdcl[i] = typecheck(externdcl[i], ctxExpr)
        }
    }

    checkMapKeys()
}
```

在主程序运行的最后，会将顶层的函数编译成中间代码并根据目标的 CPU 架构生成机器码，不过这里其实也可能会再次对外部依赖进行类型检查以验证正确性。
Go语言的编译过程其实是非常有趣并且值得学习的，通过对Go语言四个编译阶段的分析和对编译器主函数的梳理，我们能够对 Golang 的实现有一些基本的理解，掌握编译的过程之后，Go语言对于我们来讲也不再那么神秘，所以学习其编译原理的过程还是非常有必要的。

安装完成之后，在终端运行 `go version`

go version go1.13.4 darwin/amd64

#### 设置 GOPATH 环境变量

开始写 go 项目代码之前，需要我们先配置好环境变量。编辑 ~/.bash_profile

export GOPATH=$HOME/go

保存然后退出你的编辑器。然后在终端中运行下面命令

source ~/.bash_profile

> 提示：$HOME 是每个电脑下的用户主目录，每个电脑可能不同，可以在终端运行 echo $HOME 获取

GOROOT 也就是 Go 开发包的安装目录默认是在 /usr/local/go，如果没有，可以在 bash_profile 文件中设置。

export GOROOT=/usr/local/go

然后保存并退出编辑器

source ~/.bash_profile

一般的编程语言往往对工程（项目）的目录结构是没有什么规定的，但是[Go语言](http://c.biancheng.net/golang/)
我们前面讲搭建Go语言开发环境时提到的环境变量 GOPATH，项目的构建主要是靠它来实现的。这么说吧，如果想要构建一个项目，就需要将这个项目的目录添加到 GOPATH 中，多个项目之间可以使用分隔。

一个Go语言项目的目录一般包含以下三个子目录：

- src 目录：放置项目和库的源文件；
- pkg 目录：放置编译后生成的包/库的归档文件；
- bin 目录：放置编译后生成的可执行文件。


三个目录中我们需要重点关注的是 src 目录，其他两个目录了解即可，下面来分别介绍一下这三个目录。

#### src 目录

用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。
并不是说 src 目录下不能存放 Go 源文件，一般在测试或演示的时候也可以把 Go 源文件直接放在 src 目录下，但是这么做的话就只能声明该源文件属于 main 包了。正常开发中还是建议大家把 Go 源文件放入特定的目录中。
[Java](http://c.biancheng.net/java/)[C++](http://c.biancheng.net/cplus/)`package <包名> `
另外需要注意的是，Go语言会把通过命令获取到的库源文件下载到 src 目录下对应的文件夹当中。

#### pkg 目录

用于存放通过`go install `
该目录与 GOROOT 目录（也就是Go语言的安装目录）下的 pkg 目录功能类似，区别在于这里的 pkg 目录专门用来存放项目代码的归档文件。

与 pkg 目录类似，在通过命令完成安装后，保存由 Go 命令源文件生成的可执行文件。在类 Unix 操作系统下，这个可执行文件的名称与命令源文件的文件名相同。而在 Windows 操作系统下，这个可执行文件的名称则是命令源文件的文件名加 .exe 后缀。

## 源文件

上面我们提到了命令源文件和库源文件，它们到底是什么呢？

不管是命令源文件还是库源文件，在同一个目录下的所有源文件，其所属包的名称必须一致的。

