# Go 2

静态类型语言——变量是有明确类型的，编译器也会检查变量类型的正确性。

从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。

## 变量的声明

### 标准格式

Var name type 如：var a,b *int

- bool
- string
- Int int8 int16 int32 int64
- Uint uint8 uint16 unit32 unit64 uintptr
- Byte //uint8 alias
- Rune //int32 alias a Unicode code
- Float32 float64
- Complex64 complex128

### 批量格式

var (

a int

b string

c []float32

d func() bool

e struct {

​		x int

}

)

### 简短格式

名字 := 表达式

需要注意的是，简短模式（short variable declaration）有以下限制：

- 定义变量，同时显式初始化。
- 不能提供数据类型。
- 只能用在函数内部。

和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

i,j := 0,1

```go
func main(){
  x:=100
  a,s:=1,"abc"
}
```

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：

- 整型和浮点型变量的默认值为 0 和 0.0。
- 字符串变量的默认值为空字符串。
- 布尔型变量默认为 bool。
- 切片、函数、指针变量的默认为 nil。

当然，依然可以在变量声明时赋予变量一个初始值。

在**C语言**中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。

在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/[C+在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。

在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/C++ 中变量默认不初始化。

微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。

因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。 中变量默认不初始化。

微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。

因此，如果一个字符串没有结束符`\0`，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。

## 变量初始化的标准格式

var 变量名 类型 = 表达式

例如，游戏中，玩家的血量初始值为100。可以这样写：

```
var hp int = 100
```

这句代码中，hp 为变量名，类型为 int，hp 的初始值为 100。
上面代码中，100 和 int 同为 int 类型，int 可以认为是冗余信息，因此可以进一步简化初始化的写法。

## 编译器推导类型的格式

在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。

```
var hp = 100
```

等号右边的部分在编译原理里被称做右值（rvalue）
下面是编译器根据右值推导变量类型完成初始化的例子。

```go
var attack = 40
var defence = 20
var damageRate float32 = 0.17
var damage = float32(attack-defence) * damageRate
fmt.Println(damage)
```

代码说明如下：

- 第 1 和 2 行，右值为整型，attack 和 defence 变量的类型为 int。
- 第 3 行，表达式的右值中使用了 0.17。由于[Go语言](http://c.biancheng.net/golang/)和C语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 damageRate 变量的类型，Go语言编译器会将 damageRate 类型推导为 float64，我们这里不需要 float64 的精度，所以需要强制指定类型为 float32。
- 第 4 行，将 attack 和 defence 相减后的数值结果依然为整型，使用 float32() 将结果转换为 float32 类型，再与 float32 类型的 damageRate 相乘后，damage 类型也是 float32 类型。

> 提示：damage 变量的右值是一个复杂的表达式，整个过程既有 attack 和 defence 的运算还有强制类型转换。强制类型转换会在后面的章节中介绍。

- 第 5 行，输出 damage 的值。

## 短变量声明并初始化

var 的变量声明还有一种更为精简的写法，例如：

```
hp := 100
```

这是Go语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。

> 注意：由于使用了`:=`，而不是赋值的`=`，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。

如果 hp 已经被声明过，但依然使用:=时编译器会报错，代码如下：

1. // 声明 hp 变量
2. var hp int
3. // 再次声明并赋值
4. hp := 10

编译报错如下：

no new variables on left side of :=

意思是，在“:=”的左边没有新变量出现，意思就是“:=”的左边变量已经被声明了。

---



